
% https://www.youtube.com/watch?v=T-EVqAZ9SVU
% https://www.youtube.com/watch?v=JQbhxgPEhns
% https://youtu.be/teI6O4bFpD4
% https://youtu.be/FbjBUlM6p8g

\section{Introduction}
$\indent$Flow control and Error control are the two main responsibilities of the data link layer, which is a communication channel for node-to-node delivery of the data. The functions of the flow and error control are explained as follows.\\

Flow control mainly coordinates with the amount of data that can be sent before receiving an acknowledgment from the receiver and it is one of the major duties of the data link layer. For most of the communications, flow control is a set of procedures that mainly tells the sender how much data the sender can send before it must wait for an acknowledgment from the receiver.\\

A critical issue, but not really frequently occurred, in the flow control is that the processing rate is slower than the transmission rate. Due to this reason each receiving device has a block of memory that is commonly known as buffer, that is used to store the incoming data until this data will be processed. In case the buffer begins to fill-up then the receiver must be able to tell the sender to halt the transmission until once again the receiver become able to receive.\\

Meanwhile, error control contains both error detection and error correction. It mainly allows the receiver to inform the sender about any damaged or lost frames during the transmission and then it coordinates with the re-transmission of those frames by the sender.\\

The term Error control in the communications mainly refers to the methods of error detection and re-transmission. Error control is mainly implemented in a simple way and that is whenever there is an error detected during the exchange, then specified frames are re-transmitted and this process is also referred to as Automatic Repeat request(ARQ).\\

The target in this lab is to implement a UART communication between the STM32 and a simulated terminal. A data request is sent from the terminal to the STM32. Afterward, computations are performed at the STM32 before a data packet is sent to the terminal. The terminal is supposed to reply an ACK to confirm the communication successfully or not.

\newpage
\section{Proteus simulation platform}

\begin{figure}[!htp]
    \centering
    \includegraphics[width=5in]{picture/bai_6/Proteus_Simulation.PNG}
    \vspace{0.5cm}
    \caption{\textit{Simulation circuit on Proteus}}
    \label{bai4_pic_button_schematic_0}
\end{figure}

$\indent$Some new components are listed bellow:
\begin{itemize}
    \item Terminal: Right click, choose Place, Virtual Instrument, then select VIRTUAL TERMINAL.
    \item Variable resistor (RV2): Right click, choose Place, From Library, and search for the POT-HG device. The value of this device is set to the default 1k.
    \item Volt meter (for debug): Right click, choose Place, Virtual Instrument, the select DC VOLTMETER.
    \item OPAMP (U3): Right click, choose Place, From Library, and search for the OPAMP device.
\end{itemize}

The opamp is used to design a voltage follower circuit, which is one of the most popular applications for opamp. In this case, it is used to design an adc input signal, which is connected to pin PA0 of the MCU.\\

Double click on the virtual terminal and set its baudrate to 9600, 8 data bits, no parity and 1 stop bit, as follows:
\newpage
\begin{figure}[!htp]
    \centering
    \includegraphics[width=4in]{picture/bai_6/Proteus_Simulation2.PNG}
    \vspace{0.5cm}
    \caption{\textit{Terminal configuration}}
    \label{bai4_pic_button_schematic_0}
\end{figure}

\section{Project configurations}
$\indent$A new project is created with following configurations, concerning the UART for communications and ADC input for sensor reading. The pin PA5 should be an GPIO output, for LED blinky.
\subsection{UART Configuration}
$\indent$From the ioc file, select \textbf{Connectivity}, and then select the \textbf{USART2}. The parameter settings for UART channel 2 (USART2) module are depicted as follows:

\begin{figure}[!htp]
    \centering
    \includegraphics[width=4.5in]{picture/bai_6/stm32_uart_1.PNG}
    \vspace{0.5cm}
    \caption{\textit{UART configuration in STMCube}}
    \label{1}
\end{figure}

The UART channel in this lab is the Asynchronous mode, 9600 bits/s with no Parity and 1 stop bit. After the uart is configured, the pins PA2 (Tx) and PA3(Rx) are enabled. \\

Finally, the NVIC settings are checked to enable the UART interrupt, as follows:
\begin{figure}[!htp]
    \centering
    \includegraphics[width=3.5in]{picture/bai_6/stm32_uart_2.PNG}
    \vspace{0.5cm}
    \caption{\textit{Enable UART interrupt}}
    \label{2}
\end{figure}

\subsection{ADC Input}
$\indent$In order to read a voltage signal from a simulated sensor, this module is required. By selecting on \textbf{Analog}, then \textbf{ADC1}, following configurations are required:
\begin{figure}[!htp]
    \centering
    \includegraphics[width=4.5in]{picture/bai_6/stm32_adc_1.PNG}
    \vspace{0.5cm}
    \caption{\textit{Enable UART interrupt}}
    \label{3}
\end{figure}

The ADC pin is configured to PA0 of the STM32, which is shown in the pinout view dialog. \\

Finally, the PA5 is configured as a GPIO output, connected to a blinky LED.

\section{UART loop-back communication}
$\indent$This source is required to add in the main.c file, to verify the UART communication channel: sending back any character received from the terminal, which is well-known as the loop-back communication.

\begin{lstlisting}[language=C, numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=5pt][caption= Implement the UART interrupt service routine]
/* USER CODE BEGIN 0 */
uint8_t temp = 0;

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart){
	if(huart->Instance == USART2){
		HAL_UART_Transmit(&huart2, &temp, 1, 50);
		HAL_UART_Receive_IT(&huart2, &temp, 1);
	}
}
/* USER CODE END 0 */
\end{lstlisting}

When a character (or a byte) is received, this interrupt service routine is invoked. After the character is sent to the terminal, the interrupt is activated again. This source code should be placed in a user-defined section.\\

Finally, in the main function, the proposed source code is presented as follows:

\begin{lstlisting}[language=C, numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=5pt][caption=Implement the main function]
int main(void)
{
  HAL_Init();
  SystemClock_Config();

  MX_GPIO_Init();
  MX_USART2_UART_Init();
  MX_ADC1_Init();

  HAL_UART_Receive_IT(&huart2, &temp, 1);

  while (1)
  {
	  HAL_GPIO_TogglePin(LED_RED_GPIO_Port, LED_RED_Pin);
	  HAL_Delay(500);
  }
  
}
\end{lstlisting}

\section{Sensor reading}
$\indent$A simple source code to read adc value from PA0 is presented as follows:
\begin{lstlisting}[language=C, numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=5pt][caption=ADC reading from AN0]
uint32_t ADC_value = 0;
while (1)
{
  HAL_GPIO_TogglePin(LED_RED_GPIO_Port, LED_RED_Pin);
  ADC_value =  HAL_ADC_GetValue(&hadc1);
HAL_UART_Transmit(&huart2, (void *)str, sprintf(str, "%d\n", ADC_value), 1000);
  HAL_Delay(500);
}
\end{lstlisting}

Every half of second, the ADC value is read and its value is sent to the console. It is worth noticing that the number ADC\_value is convert to ascii character by  using the sprintf function.\\

The default ADC in STM32 is 13 bits, meaning that 5V is converted to 4096 decimal value. If the input is 2.5V, ADC\_value is 2048.

\section{Project description}
$\indent$In this lab, a simple communication protocol is implemented as follows:
\begin{itemize}
    \item From the console, user types \textbf{!RST\#} to ask for a sensory data.
    \item The STM32 response the ADC\_value, following a format \textbf{!ADC=1234\#}, where 1234 presents for the value of ADC\_value variable.
    \item The user ends the communication by sending \textbf{!OK\#}
\end{itemize}

The timeout for waiting the \textbf{!OK\#} at STM32 is 3 seconds. After this period, its packet is sent again. \textbf{The value is kept as the previous packet}.

\subsection{Command parser}
$\indent$This module is used to received a command from the console. As the reception process is implement by an interrupt, the complexity is considered seriously. The proposed implementation is given as follows.\\

Firstly, the received character is added into a buffer, and a flag is set to indicate that there is a new data.

\begin{lstlisting}[language=C, numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=5pt][caption= Add the received character into a buffer]
#define MAX_BUFFER_SIZE  30
uint8_t temp = 0;
uint8_t buffer[MAX_BUFFER_SIZE];
uint8_t index_buffer = 0;
uint8_t buffer_flag = 0;
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart){
	if(huart->Instance == USART2){

		//HAL_UART_Transmit(&huart2, &temp, 1, 50);
		buffer[index_buffer++] = temp;
		if(index_buffer == 30) index_buffer = 0;

		buffer_flag = 1;
		HAL_UART_Receive_IT(&huart2, &temp, 1);
	}
}
\end{lstlisting}

A state machine to extract a command is implemented in the while(1) of the main function, as follows:
\begin{lstlisting}[language=C, numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=5pt][caption= State machine to extract the command]
while (1){
    if(buffer_flag == 1){
        command_parser_fsm();
        buffer_flag = 0;
    }
}
\end{lstlisting}

The output of the command parser is to set \textbf{command\_flag} and \textbf{command\_data}. In this project, there are two commands, \textbf{RTS} and \textbf{OK}. The program skeleton is proposed as follows:
\begin{lstlisting}[language=C, numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=5pt][caption= Program structure]
while (1){
    if(buffer_flag == 1){
        command_parser_fsm();
        buffer_flag = 0;
    }
    uart_communiation_fsm();
}
\end{lstlisting}

\subsection{Project implementation}
$\indent$Students are proposed to implement 2 FSM in seperated modules. Students are asked to design the FSM before their implementations in STM32Cube.

 The complete LAB5 project source code is available at: 
\href{https://github.com/vophamk23/Microprocessor_Microcontroller_HCMUT/tree/main/STM32%20LAB%205%20-%20UART%20ADC}{GitHub - Flow and Error Control in Communication.}.    

\subsubsection{Lab Objectives: Building a Reliable Communication System}
$\indent$The primary goal of this lab is to implement a robust UART system encompassing four core functionalities:
\begin{enumerate}
    \item \textbf{Flow Control (ACK-based)}: Utilize an Acknowledgment (ACK) mechanism (\texttt{!OK\#}) to coordinate transmission. Ensure the transmitter (STM32) only sends data when the receiver (Terminal) is ready and has acknowledged the previous packet.
    \item \textbf{Error Control (Timeout ARQ)}: Establish an ARQ mechanism based on a \textbf{3-second} Timeout. The system must automatically detect communication failure and perform \textbf{Retransmission} of the stored data packet until a valid ACK is received.
    \item \textbf{Command Parser (FSM-driven)}: Develop a smart command parser using an FSM to recognize commands in the standard format \texttt{!<COMMAND\_NAME >\#}. Effectively filter out unwanted noise characters from the raw UART data stream.
    \item \textbf{Sensor Reading (ADC Integration)}: Integrate the ADC (Analog-to-Digital Converter) module to read analog voltage ($0\text{-}5\text{V}$) from pin PA0. Convert the analog signal into a digital value $(0 \rightarrow 4095)$ and serialize it into an ASCII string.
\end{enumerate}

\subsubsection{Implementation Requirements and FSM Architecture}
$\indent$The system is designed with a modular architecture featuring two independent FSMs to manage command parsing and protocol handling separately.

\subsubsubsection*{* Finite State Machine (FSM) Design}

\begin{enumerate}[(a)]
    \item \textbf{Command Parser FSM (Input Processing)}
    \begin{itemize}
        \item \textbf{Function}: Identify and validate commands from the UART Circular Buffer.
        \item \textbf{Core States}:
        \begin{itemize}
            \item \texttt{PARSER\_INIT}: Waiting for the start delimiter \texttt{!}.
            \item \texttt{PARSER\_WAIT\_COMMAND}: Collecting the command string, waiting for the end delimiter \texttt{\#}.
        \end{itemize}
        \item \textbf{Supported Commands}:
        \begin{itemize}
            \item \texttt{!RST\#}: Request to read and transmit ADC data.
            \item \texttt{!OK\#}: Acknowledgment (ACK) command.
        \end{itemize}
    \end{itemize}

    \item \textbf{UART Communication FSM (Protocol Management)}
    \begin{itemize}
        \item \textbf{Function}: Coordinate the communication flow, implement timeout, and handle ARQ.
        \item \textbf{Core States}:
        \begin{itemize}
            \item \texttt{COMM\_WAIT\_RST}: Ready to receive a new \texttt{!RST\#} request.
            \item \texttt{COMM\_WAIT\_OK}: Data (\texttt{!ADC=xxxx\#}) has been sent, the 3-second Timer is running, waiting for \texttt{!OK\#}.
        \end{itemize}
        \item \textbf{ARQ Feature}: Uses the previously read and stored ADC value for retransmission, avoiding unnecessary re-activation of the ADC module during error recovery.
    \end{itemize}
\end{enumerate}

\subsubsubsection*{\hspace{0.3cm}* Communication Protocol (3-Way Handshake)}
$\indent$The communication sequence must strictly adhere to the \textbf{Request-Response-ACK} model:

\begin{longtable}{|
    >{\centering\arraybackslash}m{0.9cm} |
    >{\centering\arraybackslash}m{4cm} |
    >{\centering\arraybackslash}m{3.2cm} |
    >{\arraybackslash}m{5cm} |
}
\hline
\textbf{Step} & \textbf{Device} & \textbf{Content} & \textbf{Purpose} \\
\hline
1 & Terminal $\rightarrow$ STM32 & 
\texttt{!RST\#} &
Request STM32 to read ADC data. \\
\hline
2 & STM32 $\rightarrow$ Terminal &
\texttt{!ADC=xxxx\#} (e.g., \texttt{!ADC=2048\#}) &
Send current ADC value ($0$–$4095$).  
Start the \textbf{3-second Timeout Timer}. \\
\hline
3 & Terminal $\rightarrow$ STM32 &
\texttt{!OK\#} &
ACK received.  
Stop Timer.  
STM32 sends \texttt{[SUCCESS]} and returns to \texttt{IDLE}. \\
\hline
\end{longtable}

\newpage
\subsubsubsection*{\hspace{0.3cm}* Error Handling Mechanism (Timeout-based Retransmission)}
$\indent$The system implements the ARQ (Automatic Repeat Request) mechanism with the following properties:

\begin{itemize}
    \item \textbf{Timeout}: 3000 milliseconds (3 seconds).
    \item \textbf{Error Detection}: If the \texttt{COMM\_WAIT\_OK} state persists beyond 3 seconds (Timer expiration), a timeout error is triggered.
    \item \textbf{Recovery (Retransmission)}:
    \begin{itemize}
        \item STM32 sends the error message: \texttt{[TIMEOUT] The value is kept as the previous packet.}
        \item Automatically retransmits the stored \texttt{!ADC=xxxx\#} packet.
        \item Resets the Timer and continues waiting for \texttt{!OK\#}.
    \end{itemize}
    \item \textbf{Attempts}: Unlimited retransmission attempts until a valid ACK is received.
\end{itemize}

\subsubsection{Proteus Simulation}

$\indent$The simulation circuit is designed to establish a realistic test environment for the UART Flow Control/ARQ system on the STM32.\\
\begin{figure}[!htp]
    \centering
    \includegraphics[width=16cm]{image/1.png}
    \vspace{0.5cm}
    \caption{\textit{Proteus of System}}
    \label{bai4_pic_fsm_for_button_processing}
\end{figure}

\newpage
\begin{table}[h]
    \centering
    \caption{Technical Analysis of the Proteus Simulation Circuit}
    \label{tab:proteus_analysis_en}
    \renewcommand{\arraystretch}{1.6}

    % Define colors
    \definecolor{headergray}{gray}{0.85}
    \definecolor{rowlight}{gray}{0.95}

    \begin{tabular}{
        >{\bfseries}m{3.2cm}
        >{\centering\arraybackslash}m{3.3cm}
        m{7.2cm}
    }
    \toprule
    \rowcolor{headergray}
    Component & Primary Role in Lab & Specific Technical Function \\
    \midrule

    \rowcolor{rowlight}
    STM32F103C6 & Protocol Controller &
    The central microcontroller executing the logic of the 2 FSMs (Parser and Communication).
    Handles UART , ADC, and Timer-based ARQ/Timeout. \\
    \midrule

    Virtual Terminal & HMI \& Control Interface &
    Simulates the PC side.
    Generates Commands (\texttt{!RST\#}, \texttt{!OK\#}) and displays \texttt{!ADC=xxxx\#} via UART. \\
    \midrule

    \rowcolor{rowlight}
    Potentiometer (POT) & Analog Sensor Simulation &
    Provides a variable voltage ($0 \rightarrow V_{CC}$) as analog sensor input for the ADC module. \\
    \midrule

    OPAMP (Voltage Follower) & ADC Input Optimization &
    Acts as a buffer to prevent loading effect and ensure low output impedance for ADC input (\textbf{PA0}).
    Improves A/D conversion accuracy. \\
    \midrule

    \rowcolor{rowlight}
    LED (PA5) & Debug Status Indicator &
    Provides visual feedback for the Communication FSM:
    lights during \texttt{WAIT\_FOR\_ACK} or on Timeout errors. \\
    \bottomrule
    \end{tabular}
\end{table}

\subsubsection{TWO STATE MACHINES (2 FSM)}

$\indent$This advanced UART communication system is architected around the Finite State Machine (FSM) model to ensure modularity, robust error handling, and effective data flow management (Flow Control). The system utilizes two (2) independent FSMs operating in parallel to clearly separate input processing responsibilities from protocol management.

\subsubsubsection*{\hspace{0.3cm}a) Command Parser FSM (Input Processor)}
$\indent$The Command Parser FSM is designed to process the raw data stream received via UART. Its main role is noise filtering and command pattern recognition based on the required structure: \texttt{!COMMAND\_NAME\#}.

\begin{table}[h]
    \centering
    \caption{Command Parser FSM States}
    \renewcommand{\arraystretch}{1.6}

    % Define colors
    \definecolor{headergray}{gray}{0.85}
    \definecolor{rowlight}{gray}{0.95}

    \begin{tabular}{
        >{\bfseries}m{3.2cm}
        m{5.5cm}
        m{6.5cm}
    }
    \toprule
    \rowcolor{headergray}
    State & Description & Primary Action \\
    \midrule

    \rowcolor{rowlight}
    \texttt{PARSER\_INIT} &
    \textbf{Initialization.} The FSM waits for the start delimiter \texttt{!}. &
    Ignore all characters that are not \texttt{!}. \\
    \midrule

    \texttt{PARSER\_WAIT\_COMMAND} &
    \textbf{Command Collection State.} After receiving \texttt{!}, the FSM collects subsequent characters. &
    Store incoming characters into the temporary command buffer (\texttt{temp\_cmd}). \\
    \bottomrule
    \end{tabular}
\end{table}

\subsubsubsection *{\hspace{0.3cm}* State Transition Logic (Transitions)}

$\indent$The FSM uses a temporary buffer (\texttt{temp\_cmd}) and an index (\texttt{cmd\_index}) to construct the command string.

\newpage
\begin{table}[h]
    \centering
    \caption{Command Parser FSM Transition Table}
    \renewcommand{\arraystretch}{1.5} % tăng khoảng cách dòng

    \begin{tabular}{
        >{\centering\arraybackslash}m{3.5cm} % From State
        >{\centering\arraybackslash}m{3.5cm} % To State
        >{\centering\arraybackslash}m{3.2cm} % Activation Condition
        >{\arraybackslash}m{4cm} % Action
    }
    \rowcolor{gray!25}
    \textbf{From State} & \textbf{To State} & \textbf{Activation Condition} & \textbf{Action} \\
    \midrule

    \rowcolor{gray!10}
    \texttt{PARSER\_INIT} & \texttt{PARSER\_WAIT\_COMMAND} & Character \texttt{!} is received &
    Clear buffer (\texttt{temp\_cmd}) and set \texttt{cmd\_index = 0}. Start command collection. \\

    \rowcolor{gray!03}
    \texttt{PARSER\_WAIT\_COMMAND} & \texttt{PARSER\_INIT} & Character \texttt{\#} is received &
    \textbf{Valid Command:} Compare string:  
    “RST” $\rightarrow$ \texttt{CMD\_RST},  
    “OK” $\rightarrow$ \texttt{CMD\_OK}. Reset to wait state. \\

    \rowcolor{gray!10}
    \texttt{PARSER\_WAIT\_COMMAND} & \texttt{PARSER\_WAIT\_COMMAND} & Character other than \texttt{!} or \texttt{\#} &
    Store character in \texttt{temp\_cmd} and increment \texttt{cmd\_index}. \\

    \rowcolor{gray!03}
    \texttt{PARSER\_WAIT\_COMMAND} & \texttt{PARSER\_WAIT\_COMMAND} & Character \texttt{!} is received &
    \textbf{Command Restart:} Early format error. Clear buffer and start collecting new command. \\

    \rowcolor{gray!10}
    \texttt{PARSER\_WAIT\_COMMAND} & \texttt{PARSER\_INIT} & Buffer Overflow &
    \textbf{Buffer/Format Error:} Discard current command and reset to safe state. \\

    \bottomrule
    \end{tabular}
\end{table}

\vspace{1cm}
\begin{figure}[h]
    \centering
    \begin{tcolorbox}[
        colback=gray!5,
        colframe=black,
        title=Example: Command Parsing Flow,
        fonttitle=\bfseries,
        boxrule=0.8pt,
        width=0.95\textwidth
    ]
\begin{verbatim}
Input: "abc!RST#xyz"

a -> PARSER_INIT (ignored)
b -> PARSER_INIT (ignored)
c -> PARSER_INIT (ignored)
! -> PARSER_WAIT_COMMAND (start collecting)
R -> temp_cmd = "R"
S -> temp_cmd = "RS"
T -> temp_cmd = "RST"
# -> Compare "RST" == "RST"
     => command_flag = CMD_RST 
x -> PARSER_INIT (ignored)
y -> PARSER_INIT (ignored)
z -> PARSER_INIT (ignored)
\end{verbatim}
    \end{tcolorbox}
\end{figure}


\newpage


\subsubsubsection*{\hspace{0.3cm}b) Communication FSM (Protocol Manager)}

$\indent$The Communication FSM serves as the central control logic for the entire protocol. It is responsible for coordinating the 3-Way Handshake procedure and executing the Automatic Repeat Request (ARQ) mechanism based on a strict Timeout period.


The main objective of this FSM is to Control the communication process between the STM32 and the Terminal (PC) according to the defined protocol, ensuring data integrity and reliability.

\begin{table}[h]
    \centering
    \caption{Communication FSM States and Timeout Configuration}
    \renewcommand{\arraystretch}{1.6}

    % Define colors
    \definecolor{headergray}{gray}{0.85}
    \definecolor{rowlight}{gray}{0.95}

    \begin{tabular}{
        >{\bfseries}m{3cm}
        m{4cm}
        m{5.2cm}
        >{\centering\arraybackslash}m{2.2cm}
    }
    \toprule
    \rowcolor{headergray}
    State & Description & Core Technical Role & Timeout \\
    \midrule

    \rowcolor{rowlight}
    \texttt{COMM\_IDLE} &
    \textbf{Initial State.} System is ready to begin a new communication cycle. &
    Waits for a trigger to transition into the command-waiting sequence. &
    None \\
    \midrule

    \texttt{COMM\_WAIT\_RST} &
    \textbf{Waiting for Data Request.} Awaits \texttt{!RST\#} from Terminal. &
    Filters irrelevant commands and ensures correct protocol synchronization. &
    None \\
    \midrule

    \rowcolor{rowlight}
    \texttt{COMM\_WAIT\_OK} &
    \textbf{Waiting for ACK.} STM32 has sent ADC data and is waiting for \texttt{!OK\#}. &
    Ensures \textbf{Flow Control} (no new request allowed)  
    and \textbf{Error Control} (timeout tracking). &
    3 seconds \\
    \midrule

    \texttt{COMM\_TIMEOUT} &
    \textbf{Error Handling State.} Timeout occurred in \texttt{COMM\_WAIT\_OK}. &
    Performs error recovery (ARQ) before initiating retransmission. &
    None \\
    \bottomrule
    \end{tabular}
\end{table}

\subsubsubsection *{\hspace{0.3cm}* State Transition Logic (Transitions)}

$\indent$The transitions illustrate how the Communication FSM manages Flow Control (by requiring an ACK) and initiates the ARQ mechanism to ensure reliability.


\begin{table}[h]
    \centering
    \caption{Communication FSM Transition Table}
    \renewcommand{\arraystretch}{1.25}

    \begin{tabular}{
        >{\centering\arraybackslash}p{3cm}
        >{\centering\arraybackslash}p{3cm}
        >{\centering\arraybackslash}p{4cm}
        >{\centering\arraybackslash}p{4.6cm}}
        
        \rowcolor{gray!25}
        \textbf{From State} & \textbf{To State} & \textbf{Activation Condition} & \textbf{Action} \\
        \midrule
        
        \rowcolor{gray!10}
        \texttt{COMM\_IDLE} & \texttt{COMM\_WAIT\_RST} & Automatic &
        Initializes the FSM for a new communication cycle. \\
        
        \rowcolor{gray!03}
        \texttt{COMM\_WAIT\_RST} & \texttt{COMM\_WAIT\_OK} & \texttt{CMD\_RST} event received &
        1) Read ADC.
        2) Send \texttt{!ADC=xxxx\#}.
        3) Start 3s timer. \\
        
        \rowcolor{gray!10}
        \texttt{COMM\_WAIT\_OK} & \texttt{COMM\_WAIT\_RST} & \texttt{CMD\_OK} event received (ACK) &
        1) Stop timer.
        2) Send \texttt{[SUCCESS]...}.
        3) Wait for next \texttt{!RST\#}. \\
        
        \rowcolor{gray!03}
        \texttt{COMM\_WAIT\_OK} & \texttt{COMM\_TIMEOUT} & Timer $\ge 3$ s &
        Switch to ARQ timeout handling. \\
        
        \rowcolor{gray!10}
        \texttt{COMM\_TIMEOUT} & \texttt{COMM\_WAIT\_OK} & Automatic &
        1) Send \texttt{[TIMEOUT]...}.
        2) Retransmit ADC value.
        3) Reset and restart 3s timer. \\
        
        \bottomrule
    \end{tabular}
\end{table}

\newpage

\subsubsubsection*{\hspace{0.3cm}c) Two FSM Architecture}

\begin{figure}[!htp]
    \centering
    \includegraphics[width=12cm]{image/2.png}
    \vspace{0.5cm}
    \caption{\textit{Command Parser FSM}}
    \label{bai4_pic_fsm_for_button_processing}
\end{figure}


\begin{figure}[!htp]
    \centering
    \includegraphics[width=17cm]{image/3.png}
    \vspace{0.5cm}
    \caption{\textit{Communication FSM}}
    \label{bai4_pic_fsm_for_button_processing}
\end{figure}


\subsubsection{Source Code}


\subsubsection*{1. \fcolorbox{black}{gray!10}{\ttfamily\textbf{command\_parser.c}}}

\begin{lstlisting}[language=C, numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=5pt][caption=An example for your source code]
/* command_parser.c - Command parser using FSM for UART data
 * FUNCTION: Parse commands from UART buffer in format: !COMMAND#
 * SUPPORTED COMMANDS: !RST# and !OK#
 */
#include "command_parser.h"
#include "string.h"

// GLOBAL VARIABLES
static ParserState parser_state = PARSER_INIT;  

// Current position in temp buffer
static uint8_t cmd_index = 0;  

// Temporary buffer for command being received
static uint8_t temp_cmd[MAX_CMD_LENGTH]; 

// Last processed position in UART buffer
static uint8_t last_processed_index = 0;          

// INITIALIZATION
void command_parser_init(void)
{
    parser_state = PARSER_INIT;    // FSM starts waiting for '!'
    cmd_index = 0;                 // No characters in temp buffer yet
    command_flag = CMD_NONE;       // No command received yet
    last_processed_index = 0;      // Start from beginning of buffer

    // Clear all buffers
    memset(command_data, 0, MAX_CMD_LENGTH);
    memset(temp_cmd, 0, MAX_CMD_LENGTH);
}


 /*
 1. Iterate through ALL new characters in buffer (not yet processed)
 2. For each character, process according to current state
 3. Update state and temp buffer */
void command_parser_fsm(void)
{
    // STEP 1: Iterate through ALL new characters in buffer
    while (last_processed_index != index_buffer)
    {
        // Get character at unprocessed position
        uint8_t received_char = buffer[last_processed_index];

        // Move pointer to next position (circular buffer)
        last_processed_index++;
        if (last_processed_index >= MAX_BUFFER_SIZE)
        {
            last_processed_index = 0; // Wrap around to beginning
        }

        // STEP 2: FSM state
        switch (parser_state)
        {
        // STATE 1: PARSER_INIT - Waiting for start character '!'
        case PARSER_INIT:
            if (received_char == '!')
            {
                // Detected command start
                parser_state = PARSER_WAIT_COMMAND;  
                cmd_index = 0;                       
                memset(temp_cmd, 0, MAX_CMD_LENGTH); 
            }
            // Other characters - Ignore
            // Example: If receiving "abc!" then ignore "a", "b", "c"
            break;

        // STATE 2: PARSER_WAIT_COMMAND
        case PARSER_WAIT_COMMAND:
            // CASE 1: Received end character '#'
            if (received_char == '#')
            {
                // Null-terminate string in temp_cmd
                temp_cmd[cmd_index] = '\0';
                // Compare received command with valid commands
                // EXAMPLES:
                // Receive "!RST#" - temp_cmd = "RST" - CMD_RST
                // Receive "!OK#"  - temp_cmd = "OK"  - CMD_OK
                // Receive "!ABC#" - temp_cmd = "ABC" -CMD_NONE 
                if (strcmp((char *)temp_cmd, "RST") == 0)
                {
                    command_flag = CMD_RST;
                    strcpy((char *)command_data, "RST");
                }
                else if (strcmp((char *)temp_cmd, "OK") == 0)
                {
                    command_flag = CMD_OK;
                    strcpy((char *)command_data, "OK");
                }
                else
                {
                    // Invalid command - Do nothing
                    command_flag = CMD_NONE;
                }
                // Reset FSM to wait for new command
                parser_state = PARSER_INIT;
                cmd_index = 0;
            }
            // CASE 2: Received '!' in the middle
            else if (received_char == '!')
            {
                // Restart: Begin receiving new command
                cmd_index = 0;
                memset(temp_cmd, 0, MAX_CMD_LENGTH);
            }
            
            // CASE 3: Received normal character (R, S, T...)
            else
            {
                if (cmd_index < MAX_CMD_LENGTH - 1)
                {
                    temp_cmd[cmd_index++] = received_char;
                }
                else
                {
                    parser_state = PARSER_INIT;  // Buffer full 
                    cmd_index = 0;
                }
            }
            break;
            
        // DEFAULT STATE: Error handling
        default:
            parser_state = PARSER_INIT; // Reset to safe state
            break;
        }
    }
}
// Get the parsed command
uint8_t get_command_flag(void)
{
    return command_flag;
}
// Clear command flag
void clear_command_flag(void)
{
    command_flag = CMD_NONE;
    memset(command_data, 0, MAX_CMD_LENGTH);
}
 
\end{lstlisting}


\subsubsection*{2. \fcolorbox{black}{gray!10}{\ttfamily\textbf{uart\_communication.c}}}
\begin{lstlisting}[language=C, numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=5pt][caption=An example for your source code]
/* uart_communication.c - UART communication protocol management using FSM
 * PROTOCOL: PC sends !RST# => STM32 sends !ADC=xxxx# => PC sends !OK# (3s timeout)
 * If timeout => Retransmit with previous value */

#include "uart_communication.h"
#include "command_parser.h"
#include "sensor.h"
#include "stdio.h"
#include "string.h"

// GLOBAL VARIABLES
static CommunicationState comm_state = COMM_IDLE; 
static uint32_t timeout_start = 0 // Timeout start timestamp (ms)
static uint32_t last_adc_value = 0;// Last transmitted ADC value

// INITIALIZATION
void uart_communication_init(void)
{
    comm_state = COMM_WAIT_RST;  // Start by waiting for RST command
    timeout_start = 0;
    last_adc_value = 0;
}

// Send ADC value via UART in format !ADC=xxxx#
void send_adc_packet(uint32_t value)
{
    char packet[50];
    // Format packet: !ADC=xxxx#
    sprintf(packet, "!ADC=%lu#\r\n", value);
    // Transmit via UART2
    HAL_UART_Transmit(&huart2, (uint8_t *)packet, 
                            strlen(packet), 1000);
    
    // Store value for potential retransmission
    last_adc_value = value;
}

/* Main FSM for managing UART communication
 STATES:
 - COMM_IDLE: Initial state, transitions to COMM_WAIT_RST
 - COMM_WAIT_RST: Waiting for !RST# command from PC
 - COMM_WAIT_OK: Waiting for !OK# confirmation (3 second timeout)
 - COMM_TIMEOUT: Timeout occurred, retransmit previous value
 */
void uart_communication_fsm(void)
{
    // Get current command from parser
    uint8_t cmd = get_command_flag();

    switch (comm_state)
    {
    // STATE 1: COMM_IDLE - Initial idle state
    case COMM_IDLE:
        comm_state = COMM_WAIT_RST;  // Transition immediately
        break;

    // STATE 2: COMM_WAIT_RST - Waiting for !RST# from PC
    case COMM_WAIT_RST:
        if (cmd == CMD_RST)
        {
            // Clear the command flag
            clear_command_flag();
            // Read ADC value from sensor
            adc_value = read_adc_value();
            
        // Send debug info (optional)
        char debug_msg[50];
        sprintf(debug_msg, "[INFO] ADC Read: %lu\r\n", adc_value);
        HAL_UART_Transmit(&huart2, (uint8_t *)debug_msg,                                strlen(debug_msg), 100);

            // Send ADC packet to PC
            send_adc_packet(adc_value);
            // Start timeout counter
            timeout_start = HAL_GetTick();
            // Transition to waiting for OK
            comm_state = COMM_WAIT_OK;
        }
        break;

    // STATE 3: COMM_WAIT_OK - Waiting for !OK# confirmation
    case COMM_WAIT_OK:
        // Case 1: Received !OK# => Success
        if (cmd == CMD_OK)
        {
            clear_command_flag();
            // Send success message
            char success_msg[] = "[SUCCESS] Communication complete                                                      !\r\n\r\n";
            HAL_UART_Transmit(&huart2, (uint8_t *)success_msg,                                          strlen(success_msg), 100);
            // Return to waiting for next RST
            comm_state = COMM_WAIT_RST;
        }
        
        // Case 2: Timeout (3 seconds elapsed)
        else if (HAL_GetTick() - timeout_start >= TIMEOUT_DURATION)
        {
            comm_state = COMM_TIMEOUT;  // Handle timeout
        }
        break;
    // STATE 4: COMM_TIMEOUT - Handle timeout and retransmit
    case COMM_TIMEOUT:
    {
        // Send timeout notification
        char timeout_msg[] = "[TIMEOUT] The value is kept as the previous packet.\r\n";
        HAL_UART_Transmit(&huart2, (uint8_t *)timeout_msg, strlen(timeout_msg), 100);
        
        // Retransmit with previous value
        send_adc_packet(last_adc_value);
        
        // Restart timeout counter
        timeout_start = HAL_GetTick();
        
        // Return to waiting for OK
        comm_state = COMM_WAIT_OK;
        break;
    }

    // DEFAULT: Error recovery
    default:
        comm_state = COMM_IDLE;  // Reset to safe state
        break;
    }
}

// Get current FSM state
CommunicationState get_communication_state(void)
{
    return comm_state;
}
 
\end{lstlisting}


\newpage
\subsubsection*{3. \fcolorbox{black}{gray!10}{\ttfamily\textbf{sensor.c}}}
\begin{lstlisting}[language=C, numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=5pt][caption=An example for your source code]
#include "sensor.h"
// CONSTANTS
#define ADC_MAX_VALUE 4095    // Maximum value for 12-bit ADC
#define VREF_MV 3300          // Reference voltage 3.3V = 3300mV

// INITIALIZATION
void sensor_init(void) {
    HAL_ADC_Start(&hadc1);
}

// READ ADC VALUE
uint32_t read_adc_value(void) {
    HAL_Delay(1);  // Short delay to ensure fresh value
    
    // Read and return ADC value
    return HAL_ADC_GetValue(&hadc1);
}

// CONVERT ADC TO VOLTAGE
uint32_t adc_to_voltage_mv(uint32_t adc_value) {
    uint32_t voltage_mv = (adc_value * VREF_MV) / ADC_MAX_VALUE;
    return voltage_mv;
}
 
\end{lstlisting}